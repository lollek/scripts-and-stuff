#! /usr/bin/env ruby

require 'cgi'
require 'socket'
require 'json'

def shellcheck_explain(shellcode, data)
  color = {"error" => "\033[1;31m",
           "warning" => "\033[1;33m",
           "info" => "\033[1;36m" }

  shellcode = shellcode.split "\n"
  current_line = 0
  data.each do |issue|
    while issue["line"] > current_line
      puts shellcode.shift
      current_line += 1
    end
    puts color[issue["level"]] +
         " " * (issue["column"] -1) +
         "^-- #{issue["message"]}\033[0m"
  end

  while not shellcode.empty?
    puts shellcode.shift
  end
end

def shellcheck shellcode
  return if shellcode.length == 0
  escaped_code = CGI.escape shellcode
  transfer_code = "script=#{escaped_code}"

  request = "POST /shellcheck.php HTTP/1.1\r\n" +
            "Host: www.shellcheck.net\r\n" +
            "Connection: close\r\n" +
            "Content-Length: #{transfer_code.size}\r\n" +
            "Content-Type: application/x-www-form-urlencoded\r\n" +
            "User-Agent: ShellCheck (https://github.com/lollek/scripts-and-stuff)\r\n\r\n" +
            transfer_code

  TCPSocket.open "shellcheck.net", 80 do |socket|
    socket.puts request
    return_next = false
    while data = socket.gets
      if return_next
        return shellcheck_explain shellcode, JSON.parse(data)
      elsif data == "\r\n"
        return_next = true
      end
    end
  end
end

if __FILE__ == $0
  if ARGV.length == 0
    shellcheck $stdin.read
  elsif ARGV.length == 1
    begin
      shellcheck File.read(ARGV[0])
    rescue => e
      $stderr.puts e
    end
  else
    $stderr.puts "Usage: #{$0} FILE\n\nIf no FILE is given, data is read from stdin"
  end
end
